// Fetcher
import { Fetcher } from "openapi-typescript-fetch";

// Types
import type { Pagination } from "../types";

// Copied types from openapi because they aren't exported from the package
type Method = "get" | "post" | "put" | "patch" | "delete" | "head" | "options";

// The autogenerated types from openapi will match this type
type OpenapiPaths<Paths> = {
  [P in keyof Paths]: {
    [M in Method]?: unknown;
  };
};

export const useAxiosCustom = <Paths extends OpenapiPaths<Paths>>(
  baseUrl: string
) => {
  // API mimics the structure of the underlying fetcher, but allows for typing overrides and typed pagination data
  const api = async <U extends keyof Paths>(url: U) => {
    // const accessToken = encodeURI(await getAccessToken());

    const instance = Fetcher.for<Paths>();
    instance.configure({
      baseUrl,
      init: {
        credentials: "include",
        headers: {
          // Grab token from useSession
          // Authorization: `Bearer ${accessToken}`,
          "Content-Type": "application/json",
          Accept: "application/json",
        },
      },
    });

    const endpoint = instance.path(url);

    const method = <Method extends keyof Paths[U]>(method: Method) => {
      const fetcher = endpoint.method(method).create();
      const create =
        () =>
        async (...params: Parameters<typeof fetcher>) => {
          const result = await fetcher(...params);

          // For my api, pagination data is stored in the headers, so I grab that here
          // const paginationHeader = result.headers.get("x-pagination");
          // const pagination = !!paginationHeader
          //   ? (JSON.parse(paginationHeader) as Pagination)
          //   : undefined;

          return {
            result,
            data: result.data,
            // pagination,
          };
        };
      return {
        create,
      };
    };
    return {
      method,
    };
  };

  return {
    api,
  };
};
